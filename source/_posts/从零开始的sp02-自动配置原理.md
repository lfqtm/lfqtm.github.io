---
title: 从零开始的sp02-自动配置原理
date: 2021-10-18 23:04:35
tags: [springboot]
---
## springboot-自动配置原理

### 1. 配置文件

每一个springboot应用都有一个全局配置文件，application.properties或application.yml，针对各种属性可以进行自定义配置，这些配置的依据就是自动配置原理。（注：配置文件大全https://docs.spring.io/spring-boot/docs/2.5.5/reference/htmlsingle/#application-properties）

### 2. 自动版本仲裁机制

```xml
依赖管理    
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.4.RELEASE</version>
</parent>

spring-boot-starter-parent的父项目
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.4.RELEASE</version>
</parent>
```

spring-boot-dependencies，该pom文件几乎声明了所有开发中常用的依赖的版本号，后续引入模块都不需要关心版本号，这就是自动版本仲裁机制；这一机制的实现同样是自动配置。

#### 2.1 修改默认的版本（补充）

- 查看spring-boot-dependencies里面规定当前依赖的版本 用的 key

- 在当前项目里面重写配置，例如：

  ```xml
  <properties>        
      <mysql.version>5.1.43</mysql.version>    
  </properties>
  ```

### 3. 自动配置的工作原理

springboot关于自动配置的源码在spring-boot-autoconfigure-x.x.x.x.jar中：

![jar](https://upload-images.jianshu.io/upload_images/11781489-9b39864b73636b50.png?imageMogr2/auto-orient/strip|imageView2/2/w/446/format/webp)

springboot默认启用自动配置，这与@SpringBootApplication脱不了干系，@SpringBootApplication是一个复合注解，其中就包含了@EnableAutoConfiguration注解；

#### 3.1 @EnableAutoConfiguration

该注解使用@Import({AutoConfigurationImportSelector.class})的方式实现关键功能，即其导入的**AutoConfigurationImportSelector**的selectImports()方法，通过**SpringFactoriesLoader.loadFactoryNames()**扫描所有具有**META-INF/spring.factories**的jar包；这个spring.factories文件也是一组一组的key=value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔。

#### 3.1.2 自动配置生效

每一个XxxxAutoConfiguration自动配置类都是在某些条件之下才会生效的，这些条件的限制在Spring Boot中以注解的形式体现，常见的**条件注解**有如下几项：

- @ConditionalOnBean：当容器里有指定的bean的条件下。

- @ConditionalOnMissingBean：当容器里不存在指定bean的条件下。

- @ConditionalOnClass：当类路径下有指定类的条件下。

- @ConditionalOnMissingClass：当类路径下不存在指定类的条件下。

- @ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix=”xxx.xxx”, value=”enable”, matchIfMissing=true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。

以server.port=8081为例：

ServletWebServerFactoryAutoConfiguration配置类中有注解@EnableConfigurationProperties({ServerProperties.class})，注解指向的类ServerProperties中

```
@ConfigurationProperties(
  prefix = "server",
  ignoreUnknownFields = true
)
```

@ConfigurationProperties，它的作用就是从配置文件中绑定属性到对应的bean上，而@EnableConfigurationProperties负责导入这个已经绑定了属性的bean到spring容器中（见上面截图）。那么所有其他的和这个类相关的属性都可以在全局配置文件中定义，也就是说，真正“限制”我们可以在全局配置文件中配置哪些属性的类就是这些XxxxProperties类，它与配置文件中定义的prefix关键字开头的一组属性是唯一对应的；

至此，我们大致可以了解。在全局配置的属性如：server.port等，通过@ConfigurationProperties注解，绑定到对应的XxxxProperties配置实体类上封装为一个bean，然后再通过@EnableConfigurationProperties注解导入到Spring容器中。

#### 4. 场景启动器

1、见到很多 spring-boot-starter-* ： *就某种场景 ；

2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入 ；

3、SpringBoot所有支持的场景 https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter ；

4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器；

5、所有场景启动器最底层的依赖：

```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter</artifactId>  
    <version>2.3.4.RELEASE</version>  
    <scope>compile</scope> 
</dependency>
```

